/* timer.c generated by valac 0.46.0.4-d3026, the Vala compiler
 * generated from timer.vala, do not modify */

/*
 * Copyright (C) 2013  Paolo Borelli <pborelli@gnome.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <cairo.h>
#include <glib.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>

#define CLOCKS_TYPE_ANALOG_FRAME (clocks_analog_frame_get_type ())
#define CLOCKS_ANALOG_FRAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_TYPE_ANALOG_FRAME, ClocksAnalogFrame))
#define CLOCKS_ANALOG_FRAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_TYPE_ANALOG_FRAME, ClocksAnalogFrameClass))
#define CLOCKS_IS_ANALOG_FRAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_TYPE_ANALOG_FRAME))
#define CLOCKS_IS_ANALOG_FRAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_TYPE_ANALOG_FRAME))
#define CLOCKS_ANALOG_FRAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_TYPE_ANALOG_FRAME, ClocksAnalogFrameClass))

typedef struct _ClocksAnalogFrame ClocksAnalogFrame;
typedef struct _ClocksAnalogFrameClass ClocksAnalogFrameClass;
typedef struct _ClocksAnalogFramePrivate ClocksAnalogFramePrivate;

#define CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME (clocks_timer_countdown_frame_get_type ())
#define CLOCKS_TIMER_COUNTDOWN_FRAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME, ClocksTimerCountdownFrame))
#define CLOCKS_TIMER_COUNTDOWN_FRAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME, ClocksTimerCountdownFrameClass))
#define CLOCKS_TIMER_IS_COUNTDOWN_FRAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME))
#define CLOCKS_TIMER_IS_COUNTDOWN_FRAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME))
#define CLOCKS_TIMER_COUNTDOWN_FRAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME, ClocksTimerCountdownFrameClass))

typedef struct _ClocksTimerCountdownFrame ClocksTimerCountdownFrame;
typedef struct _ClocksTimerCountdownFrameClass ClocksTimerCountdownFrameClass;
typedef struct _ClocksTimerCountdownFramePrivate ClocksTimerCountdownFramePrivate;
enum  {
	CLOCKS_TIMER_COUNTDOWN_FRAME_0_PROPERTY,
	CLOCKS_TIMER_COUNTDOWN_FRAME_SPAN_PROPERTY,
	CLOCKS_TIMER_COUNTDOWN_FRAME_NUM_PROPERTIES
};
static GParamSpec* clocks_timer_countdown_frame_properties[CLOCKS_TIMER_COUNTDOWN_FRAME_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define CLOCKS_TYPE_CLOCK (clocks_clock_get_type ())
#define CLOCKS_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_TYPE_CLOCK, ClocksClock))
#define CLOCKS_IS_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_TYPE_CLOCK))
#define CLOCKS_CLOCK_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), CLOCKS_TYPE_CLOCK, ClocksClockIface))

typedef struct _ClocksClock ClocksClock;
typedef struct _ClocksClockIface ClocksClockIface;

#define CLOCKS_TYPE_HEADER_BAR (clocks_header_bar_get_type ())
#define CLOCKS_HEADER_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_TYPE_HEADER_BAR, ClocksHeaderBar))
#define CLOCKS_HEADER_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_TYPE_HEADER_BAR, ClocksHeaderBarClass))
#define CLOCKS_IS_HEADER_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_TYPE_HEADER_BAR))
#define CLOCKS_IS_HEADER_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_TYPE_HEADER_BAR))
#define CLOCKS_HEADER_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_TYPE_HEADER_BAR, ClocksHeaderBarClass))

typedef struct _ClocksHeaderBar ClocksHeaderBar;
typedef struct _ClocksHeaderBarClass ClocksHeaderBarClass;
typedef enum  {
	CLOCKS_PANEL_ID_WORLD,
	CLOCKS_PANEL_ID_ALARM,
	CLOCKS_PANEL_ID_STOPWATCH,
	CLOCKS_PANEL_ID_TIMER
} ClocksPanelId;

#define CLOCKS_TYPE_PANEL_ID (clocks_panel_id_get_type ())

#define CLOCKS_TIMER_TYPE_FACE (clocks_timer_face_get_type ())
#define CLOCKS_TIMER_FACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_TIMER_TYPE_FACE, ClocksTimerFace))
#define CLOCKS_TIMER_FACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_TIMER_TYPE_FACE, ClocksTimerFaceClass))
#define CLOCKS_TIMER_IS_FACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_TIMER_TYPE_FACE))
#define CLOCKS_TIMER_IS_FACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_TIMER_TYPE_FACE))
#define CLOCKS_TIMER_FACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_TIMER_TYPE_FACE, ClocksTimerFaceClass))

typedef struct _ClocksTimerFace ClocksTimerFace;
typedef struct _ClocksTimerFaceClass ClocksTimerFaceClass;
typedef struct _ClocksTimerFacePrivate ClocksTimerFacePrivate;
typedef enum  {
	CLOCKS_TIMER_FACE_STATE_STOPPED,
	CLOCKS_TIMER_FACE_STATE_RUNNING,
	CLOCKS_TIMER_FACE_STATE_PAUSED
} ClocksTimerFaceState;

#define CLOCKS_TIMER_FACE_TYPE_STATE (clocks_timer_face_state_get_type ())

#define CLOCKS_UTILS_TYPE_BELL (clocks_utils_bell_get_type ())
#define CLOCKS_UTILS_BELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBell))
#define CLOCKS_UTILS_BELL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBellClass))
#define CLOCKS_UTILS_IS_BELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_UTILS_TYPE_BELL))
#define CLOCKS_UTILS_IS_BELL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_UTILS_TYPE_BELL))
#define CLOCKS_UTILS_BELL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBellClass))

typedef struct _ClocksUtilsBell ClocksUtilsBell;
typedef struct _ClocksUtilsBellClass ClocksUtilsBellClass;
enum  {
	CLOCKS_TIMER_FACE_0_PROPERTY,
	CLOCKS_TIMER_FACE_LABEL_PROPERTY,
	CLOCKS_TIMER_FACE_ICON_NAME_PROPERTY,
	CLOCKS_TIMER_FACE_HEADER_BAR_PROPERTY,
	CLOCKS_TIMER_FACE_PANEL_ID_PROPERTY,
	CLOCKS_TIMER_FACE_STATE_PROPERTY,
	CLOCKS_TIMER_FACE_NUM_PROPERTIES
};
static GParamSpec* clocks_timer_face_properties[CLOCKS_TIMER_FACE_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))

#define CLOCKS_TYPE_APPLICATION (clocks_application_get_type ())
#define CLOCKS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_TYPE_APPLICATION, ClocksApplication))
#define CLOCKS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_TYPE_APPLICATION, ClocksApplicationClass))
#define CLOCKS_IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_TYPE_APPLICATION))
#define CLOCKS_IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_TYPE_APPLICATION))
#define CLOCKS_APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_TYPE_APPLICATION, ClocksApplicationClass))

typedef struct _ClocksApplication ClocksApplication;
typedef struct _ClocksApplicationClass ClocksApplicationClass;
enum  {
	CLOCKS_TIMER_FACE_RING_SIGNAL,
	CLOCKS_TIMER_FACE_NUM_SIGNALS
};
static guint clocks_timer_face_signals[CLOCKS_TIMER_FACE_NUM_SIGNALS] = {0};

struct _ClocksAnalogFrame {
	GtkBin parent_instance;
	ClocksAnalogFramePrivate * priv;
};

struct _ClocksAnalogFrameClass {
	GtkBinClass parent_class;
	void (*draw_progress) (ClocksAnalogFrame* self, cairo_t* cr, gint center_x, gint center_y, gint radius);
};

struct _ClocksTimerCountdownFrame {
	ClocksAnalogFrame parent_instance;
	ClocksTimerCountdownFramePrivate * priv;
};

struct _ClocksTimerCountdownFrameClass {
	ClocksAnalogFrameClass parent_class;
};

struct _ClocksTimerCountdownFramePrivate {
	gdouble _span;
	gdouble elapsed;
	gdouble elapsed_before_pause;
};

struct _ClocksClockIface {
	GTypeInterface parent_iface;
	void (*activate_new) (ClocksClock* self);
	void (*activate_select_all) (ClocksClock* self);
	void (*activate_select_none) (ClocksClock* self);
	gboolean (*escape_pressed) (ClocksClock* self);
	void (*back) (ClocksClock* self);
	void (*update_header_bar) (ClocksClock* self);
	const gchar* (*get_label) (ClocksClock* self);
	void (*set_label) (ClocksClock* self, const gchar* value);
	const gchar* (*get_icon_name) (ClocksClock* self);
	void (*set_icon_name) (ClocksClock* self, const gchar* value);
	ClocksHeaderBar* (*get_header_bar) (ClocksClock* self);
	void (*set_header_bar) (ClocksClock* self, ClocksHeaderBar* value);
	ClocksPanelId (*get_panel_id) (ClocksClock* self);
	void (*set_panel_id) (ClocksClock* self, ClocksPanelId value);
};

struct _ClocksTimerFace {
	GtkStack parent_instance;
	ClocksTimerFacePrivate * priv;
};

struct _ClocksTimerFaceClass {
	GtkStackClass parent_class;
	void (*ring) (ClocksTimerFace* self);
};

struct _ClocksTimerFacePrivate {
	gchar* _label;
	gchar* _icon_name;
	ClocksHeaderBar* _header_bar;
	ClocksPanelId _panel_id;
	ClocksTimerFaceState _state;
	GSettings* settings;
	gdouble span;
	GTimer* timer;
	guint timeout_id;
	ClocksUtilsBell* bell;
	GNotification* notification;
	ClocksAnalogFrame* setup_frame;
	GtkGrid* grid_spinbuttons;
	GtkGrid* grid_labels;
	GtkSpinButton* h_spinbutton;
	GtkSpinButton* m_spinbutton;
	GtkSpinButton* s_spinbutton;
	GtkButton* start_button;
	ClocksTimerCountdownFrame* countdown_frame;
	GtkSpinButton* h_label;
	GtkSpinButton* m_label;
	GtkSpinButton* s_label;
	GtkButton* left_button;
};

static gint ClocksTimerCountdownFrame_private_offset;
static gpointer clocks_timer_countdown_frame_parent_class = NULL;
static gint ClocksTimerFace_private_offset;
static gpointer clocks_timer_face_parent_class = NULL;
static ClocksClockIface * clocks_timer_face_clocks_clock_parent_iface = NULL;

GType clocks_analog_frame_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClocksAnalogFrame, g_object_unref)
GType clocks_timer_countdown_frame_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClocksTimerCountdownFrame, g_object_unref)
static gdouble clocks_timer_countdown_frame_get_progress (ClocksTimerCountdownFrame* self);
gdouble clocks_timer_countdown_frame_get_span (ClocksTimerCountdownFrame* self);
void clocks_timer_countdown_frame_update (ClocksTimerCountdownFrame* self,
                                          gdouble e);
void clocks_timer_countdown_frame_pause (ClocksTimerCountdownFrame* self);
void clocks_timer_countdown_frame_reset (ClocksTimerCountdownFrame* self);
static void clocks_timer_countdown_frame_real_draw_progress (ClocksAnalogFrame* base,
                                                      cairo_t* cr,
                                                      gint center_x,
                                                      gint center_y,
                                                      gint radius);
#define CLOCKS_ANALOG_FRAME_LINE_WIDTH 6
ClocksTimerCountdownFrame* clocks_timer_countdown_frame_new (void);
ClocksTimerCountdownFrame* clocks_timer_countdown_frame_construct (GType object_type);
ClocksAnalogFrame* clocks_analog_frame_new (void);
ClocksAnalogFrame* clocks_analog_frame_construct (GType object_type);
void clocks_timer_countdown_frame_set_span (ClocksTimerCountdownFrame* self,
                                            gdouble value);
static void clocks_timer_countdown_frame_finalize (GObject * obj);
static void _vala_clocks_timer_countdown_frame_get_property (GObject * object,
                                                      guint property_id,
                                                      GValue * value,
                                                      GParamSpec * pspec);
static void _vala_clocks_timer_countdown_frame_set_property (GObject * object,
                                                      guint property_id,
                                                      const GValue * value,
                                                      GParamSpec * pspec);
GType clocks_header_bar_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClocksHeaderBar, g_object_unref)
GType clocks_panel_id_get_type (void) G_GNUC_CONST;
GType clocks_clock_get_type (void) G_GNUC_CONST;
GType clocks_timer_face_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClocksTimerFace, g_object_unref)
GType clocks_timer_face_state_get_type (void) G_GNUC_CONST;
GType clocks_utils_bell_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClocksUtilsBell, g_object_unref)
ClocksTimerFace* clocks_timer_face_new (ClocksHeaderBar* header_bar);
ClocksTimerFace* clocks_timer_face_construct (GType object_type,
                                              ClocksHeaderBar* header_bar);
static void __lambda49_ (ClocksTimerFace* self);
static void ___lambda49__gtk_widget_destroy (GtkWidget* _sender,
                                      gpointer self);
ClocksUtilsBell* clocks_utils_bell_new (const gchar* soundid);
ClocksUtilsBell* clocks_utils_bell_construct (GType object_type,
                                              const gchar* soundid);
static void clocks_timer_face_reset (ClocksTimerFace* self);
static gboolean clocks_timer_face_show_leading_zeros (ClocksTimerFace* self,
                                               GtkSpinButton* spin_button);
static gboolean _clocks_timer_face_show_leading_zeros_gtk_spin_button_output (GtkSpinButton* _sender,
                                                                       gpointer self);
static gint clocks_timer_face_input_minutes (ClocksTimerFace* self,
                                      GtkSpinButton* spin_button,
                                      gdouble* new_value);
static gint _clocks_timer_face_input_minutes_gtk_spin_button_input (GtkSpinButton* _sender,
                                                             gdouble* new_value,
                                                             gpointer self);
static gint clocks_timer_face_input_seconds (ClocksTimerFace* self,
                                      GtkSpinButton* spin_button,
                                      gdouble* new_value);
static gint _clocks_timer_face_input_seconds_gtk_spin_button_input (GtkSpinButton* _sender,
                                                             gdouble* new_value,
                                                             gpointer self);
static void clocks_timer_face_update_start_button (ClocksTimerFace* self);
static void _clocks_timer_face_update_start_button_gtk_editable_changed (GtkEditable* _sender,
                                                                  gpointer self);
static void clocks_timer_face_on_start_button_clicked (ClocksTimerFace* self);
static void clocks_timer_face_start (ClocksTimerFace* self);
static void _clocks_timer_face_on_start_button_clicked_gtk_button_clicked (GtkButton* _sender,
                                                                    gpointer self);
static void clocks_timer_face_on_left_button_clicked (ClocksTimerFace* self);
ClocksTimerFaceState clocks_timer_face_get_state (ClocksTimerFace* self);
static void clocks_timer_face_pause (ClocksTimerFace* self);
static void _clocks_timer_face_on_left_button_clicked_gtk_button_clicked (GtkButton* _sender,
                                                                   gpointer self);
static void clocks_timer_face_on_right_button_clicked (ClocksTimerFace* self);
static void _clocks_timer_face_on_right_button_clicked_gtk_button_clicked (GtkButton* _sender,
                                                                    gpointer self);
static void clocks_timer_face_set_state (ClocksTimerFace* self,
                                  ClocksTimerFaceState value);
static void clocks_timer_face_update_countdown_label (ClocksTimerFace* self,
                                               gint h,
                                               gint m,
                                               gint s);
static gboolean __lambda50_ (ClocksTimerFace* self);
static void clocks_timer_face_update_countdown (ClocksTimerFace* self,
                                         gdouble elapsed);
static gboolean ___lambda50__gsource_func (gpointer self);
void clocks_utils_time_to_hms (gdouble t,
                               gint* h,
                               gint* m,
                               gint* s,
                               gdouble* remainder);
static void clocks_timer_face_real_grab_focus (GtkWidget* base);
static gboolean clocks_timer_face_real_escape_pressed (ClocksClock* base);
static void clocks_timer_face_real_ring (ClocksTimerFace* self);
GType clocks_application_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClocksApplication, g_object_unref)
void clocks_application_send_notification (ClocksApplication* self,
                                           const gchar* notification_id,
                                           GNotification* notification);
void clocks_utils_bell_ring_once (ClocksUtilsBell* self);
static void clocks_timer_face_finalize (GObject * obj);
const gchar* clocks_clock_get_label (ClocksClock* self);
const gchar* clocks_clock_get_icon_name (ClocksClock* self);
ClocksHeaderBar* clocks_clock_get_header_bar (ClocksClock* self);
ClocksPanelId clocks_clock_get_panel_id (ClocksClock* self);
static void _vala_clocks_timer_face_get_property (GObject * object,
                                           guint property_id,
                                           GValue * value,
                                           GParamSpec * pspec);
void clocks_clock_set_label (ClocksClock* self,
                             const gchar* value);
void clocks_clock_set_icon_name (ClocksClock* self,
                                 const gchar* value);
void clocks_clock_set_header_bar (ClocksClock* self,
                                  ClocksHeaderBar* value);
void clocks_clock_set_panel_id (ClocksClock* self,
                                ClocksPanelId value);
static void _vala_clocks_timer_face_set_property (GObject * object,
                                           guint property_id,
                                           const GValue * value,
                                           GParamSpec * pspec);

static inline gpointer
clocks_timer_countdown_frame_get_instance_private (ClocksTimerCountdownFrame* self)
{
	return G_STRUCT_MEMBER_P (self, ClocksTimerCountdownFrame_private_offset);
}

static gdouble
clocks_timer_countdown_frame_get_progress (ClocksTimerCountdownFrame* self)
{
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_;
	gdouble result = 0.0;
#line 28 "../src/timer.vala"
	g_return_val_if_fail (self != NULL, 0.0);
#line 29 "../src/timer.vala"
	_tmp1_ = self->priv->_span;
#line 29 "../src/timer.vala"
	if (_tmp1_ != ((gdouble) 0)) {
#line 375 "timer.c"
		gdouble _tmp2_;
#line 29 "../src/timer.vala"
		_tmp2_ = self->priv->_span;
#line 29 "../src/timer.vala"
		_tmp0_ = (self->priv->elapsed_before_pause + self->priv->elapsed) / _tmp2_;
#line 381 "timer.c"
	} else {
#line 29 "../src/timer.vala"
		_tmp0_ = (gdouble) 0;
#line 385 "timer.c"
	}
#line 29 "../src/timer.vala"
	result = _tmp0_;
#line 29 "../src/timer.vala"
	return result;
#line 391 "timer.c"
}

void
clocks_timer_countdown_frame_update (ClocksTimerCountdownFrame* self,
                                     gdouble e)
{
#line 32 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 33 "../src/timer.vala"
	self->priv->elapsed = e;
#line 34 "../src/timer.vala"
	gtk_widget_queue_draw ((GtkWidget*) self);
#line 404 "timer.c"
}

void
clocks_timer_countdown_frame_pause (ClocksTimerCountdownFrame* self)
{
#line 37 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 38 "../src/timer.vala"
	self->priv->elapsed_before_pause = self->priv->elapsed_before_pause + self->priv->elapsed;
#line 39 "../src/timer.vala"
	self->priv->elapsed = (gdouble) 0;
#line 416 "timer.c"
}

void
clocks_timer_countdown_frame_reset (ClocksTimerCountdownFrame* self)
{
#line 42 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 43 "../src/timer.vala"
	self->priv->elapsed_before_pause = (gdouble) 0;
#line 44 "../src/timer.vala"
	self->priv->elapsed = (gdouble) 0;
#line 428 "timer.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 49 "../src/timer.vala"
	return self ? g_object_ref (self) : NULL;
#line 436 "timer.c"
}

static void
clocks_timer_countdown_frame_real_draw_progress (ClocksAnalogFrame* base,
                                                 cairo_t* cr,
                                                 gint center_x,
                                                 gint center_y,
                                                 gint radius)
{
	ClocksTimerCountdownFrame * self;
	gdouble progress = 0.0;
	GtkStyleContext* context = NULL;
	GtkStyleContext* _tmp0_;
	GtkStyleContext* _tmp1_;
	GdkRGBA color = {0};
	GdkRGBA _tmp2_ = {0};
	GdkRGBA _tmp3_;
#line 47 "../src/timer.vala"
	self = (ClocksTimerCountdownFrame*) base;
#line 47 "../src/timer.vala"
	g_return_if_fail (cr != NULL);
#line 48 "../src/timer.vala"
	progress = clocks_timer_countdown_frame_get_progress (self);
#line 49 "../src/timer.vala"
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
#line 49 "../src/timer.vala"
	_tmp1_ = _g_object_ref0 (_tmp0_);
#line 49 "../src/timer.vala"
	context = _tmp1_;
#line 51 "../src/timer.vala"
	gtk_style_context_save (context);
#line 52 "../src/timer.vala"
	gtk_style_context_add_class (context, "progress");
#line 54 "../src/timer.vala"
	gtk_style_context_get_color (context, gtk_style_context_get_state (context), &_tmp2_);
#line 54 "../src/timer.vala"
	color = _tmp2_;
#line 56 "../src/timer.vala"
	cairo_arc (cr, (gdouble) center_x, (gdouble) center_y, (gdouble) (radius - (CLOCKS_ANALOG_FRAME_LINE_WIDTH / 2)), 1.5 * G_PI, (1.5 + ((1 - progress) * 2)) * G_PI);
#line 57 "../src/timer.vala"
	_tmp3_ = color;
#line 57 "../src/timer.vala"
	gdk_cairo_set_source_rgba (cr, &_tmp3_);
#line 58 "../src/timer.vala"
	cairo_set_line_width (cr, (gdouble) CLOCKS_ANALOG_FRAME_LINE_WIDTH);
#line 59 "../src/timer.vala"
	cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
#line 60 "../src/timer.vala"
	cairo_stroke (cr);
#line 62 "../src/timer.vala"
	gtk_style_context_restore (context);
#line 47 "../src/timer.vala"
	_g_object_unref0 (context);
#line 490 "timer.c"
}

ClocksTimerCountdownFrame*
clocks_timer_countdown_frame_construct (GType object_type)
{
	ClocksTimerCountdownFrame * self = NULL;
#line 22 "../src/timer.vala"
	self = (ClocksTimerCountdownFrame*) clocks_analog_frame_construct (object_type);
#line 22 "../src/timer.vala"
	return self;
#line 501 "timer.c"
}

ClocksTimerCountdownFrame*
clocks_timer_countdown_frame_new (void)
{
#line 22 "../src/timer.vala"
	return clocks_timer_countdown_frame_construct (CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME);
#line 509 "timer.c"
}

gdouble
clocks_timer_countdown_frame_get_span (ClocksTimerCountdownFrame* self)
{
	gdouble result;
#line 23 "../src/timer.vala"
	g_return_val_if_fail (self != NULL, 0.0);
#line 23 "../src/timer.vala"
	result = self->priv->_span;
#line 23 "../src/timer.vala"
	return result;
#line 522 "timer.c"
}

void
clocks_timer_countdown_frame_set_span (ClocksTimerCountdownFrame* self,
                                       gdouble value)
{
#line 23 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 23 "../src/timer.vala"
	if (clocks_timer_countdown_frame_get_span (self) != value) {
#line 23 "../src/timer.vala"
		self->priv->_span = value;
#line 23 "../src/timer.vala"
		g_object_notify_by_pspec ((GObject *) self, clocks_timer_countdown_frame_properties[CLOCKS_TIMER_COUNTDOWN_FRAME_SPAN_PROPERTY]);
#line 537 "timer.c"
	}
}

static void
clocks_timer_countdown_frame_class_init (ClocksTimerCountdownFrameClass * klass,
                                         gpointer klass_data)
{
#line 22 "../src/timer.vala"
	clocks_timer_countdown_frame_parent_class = g_type_class_peek_parent (klass);
#line 22 "../src/timer.vala"
	g_type_class_adjust_private_offset (klass, &ClocksTimerCountdownFrame_private_offset);
#line 22 "../src/timer.vala"
	((ClocksAnalogFrameClass *) klass)->draw_progress = (void (*) (ClocksAnalogFrame*, cairo_t*, gint, gint, gint)) clocks_timer_countdown_frame_real_draw_progress;
#line 22 "../src/timer.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_clocks_timer_countdown_frame_get_property;
#line 22 "../src/timer.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_clocks_timer_countdown_frame_set_property;
#line 22 "../src/timer.vala"
	G_OBJECT_CLASS (klass)->finalize = clocks_timer_countdown_frame_finalize;
#line 22 "../src/timer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_TIMER_COUNTDOWN_FRAME_SPAN_PROPERTY, clocks_timer_countdown_frame_properties[CLOCKS_TIMER_COUNTDOWN_FRAME_SPAN_PROPERTY] = g_param_spec_double ("span", "span", "span", -G_MAXDOUBLE, G_MAXDOUBLE, (gdouble) 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 559 "timer.c"
}

static void
clocks_timer_countdown_frame_instance_init (ClocksTimerCountdownFrame * self,
                                            gpointer klass)
{
#line 22 "../src/timer.vala"
	self->priv = clocks_timer_countdown_frame_get_instance_private (self);
#line 23 "../src/timer.vala"
	self->priv->_span = (gdouble) 0;
#line 570 "timer.c"
}

static void
clocks_timer_countdown_frame_finalize (GObject * obj)
{
	ClocksTimerCountdownFrame * self;
#line 22 "../src/timer.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME, ClocksTimerCountdownFrame);
#line 22 "../src/timer.vala"
	G_OBJECT_CLASS (clocks_timer_countdown_frame_parent_class)->finalize (obj);
#line 581 "timer.c"
}

GType
clocks_timer_countdown_frame_get_type (void)
{
	static volatile gsize clocks_timer_countdown_frame_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_timer_countdown_frame_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClocksTimerCountdownFrameClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) clocks_timer_countdown_frame_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClocksTimerCountdownFrame), 0, (GInstanceInitFunc) clocks_timer_countdown_frame_instance_init, NULL };
		GType clocks_timer_countdown_frame_type_id;
		clocks_timer_countdown_frame_type_id = g_type_register_static (CLOCKS_TYPE_ANALOG_FRAME, "ClocksTimerCountdownFrame", &g_define_type_info, 0);
		ClocksTimerCountdownFrame_private_offset = g_type_add_instance_private (clocks_timer_countdown_frame_type_id, sizeof (ClocksTimerCountdownFramePrivate));
		g_once_init_leave (&clocks_timer_countdown_frame_type_id__volatile, clocks_timer_countdown_frame_type_id);
	}
	return clocks_timer_countdown_frame_type_id__volatile;
}

static void
_vala_clocks_timer_countdown_frame_get_property (GObject * object,
                                                 guint property_id,
                                                 GValue * value,
                                                 GParamSpec * pspec)
{
	ClocksTimerCountdownFrame * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME, ClocksTimerCountdownFrame);
#line 22 "../src/timer.vala"
	switch (property_id) {
#line 22 "../src/timer.vala"
		case CLOCKS_TIMER_COUNTDOWN_FRAME_SPAN_PROPERTY:
#line 22 "../src/timer.vala"
		g_value_set_double (value, clocks_timer_countdown_frame_get_span (self));
#line 22 "../src/timer.vala"
		break;
#line 614 "timer.c"
		default:
#line 22 "../src/timer.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 22 "../src/timer.vala"
		break;
#line 620 "timer.c"
	}
}

static void
_vala_clocks_timer_countdown_frame_set_property (GObject * object,
                                                 guint property_id,
                                                 const GValue * value,
                                                 GParamSpec * pspec)
{
	ClocksTimerCountdownFrame * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME, ClocksTimerCountdownFrame);
#line 22 "../src/timer.vala"
	switch (property_id) {
#line 22 "../src/timer.vala"
		case CLOCKS_TIMER_COUNTDOWN_FRAME_SPAN_PROPERTY:
#line 22 "../src/timer.vala"
		clocks_timer_countdown_frame_set_span (self, g_value_get_double (value));
#line 22 "../src/timer.vala"
		break;
#line 640 "timer.c"
		default:
#line 22 "../src/timer.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 22 "../src/timer.vala"
		break;
#line 646 "timer.c"
	}
}

static inline gpointer
clocks_timer_face_get_instance_private (ClocksTimerFace* self)
{
	return G_STRUCT_MEMBER_P (self, ClocksTimerFace_private_offset);
}

GType
clocks_timer_face_state_get_type (void)
{
	static volatile gsize clocks_timer_face_state_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_timer_face_state_type_id__volatile)) {
		static const GEnumValue values[] = {{CLOCKS_TIMER_FACE_STATE_STOPPED, "CLOCKS_TIMER_FACE_STATE_STOPPED", "stopped"}, {CLOCKS_TIMER_FACE_STATE_RUNNING, "CLOCKS_TIMER_FACE_STATE_RUNNING", "running"}, {CLOCKS_TIMER_FACE_STATE_PAUSED, "CLOCKS_TIMER_FACE_STATE_PAUSED", "paused"}, {0, NULL, NULL}};
		GType clocks_timer_face_state_type_id;
		clocks_timer_face_state_type_id = g_enum_register_static ("ClocksTimerFaceState", values);
		g_once_init_leave (&clocks_timer_face_state_type_id__volatile, clocks_timer_face_state_type_id);
	}
	return clocks_timer_face_state_type_id__volatile;
}

static void
__lambda49_ (ClocksTimerFace* self)
{
#line 129 "../src/timer.vala"
	if (self->priv->timeout_id != ((guint) 0)) {
#line 130 "../src/timer.vala"
		g_source_remove (self->priv->timeout_id);
#line 131 "../src/timer.vala"
		self->priv->timeout_id = (guint) 0;
#line 678 "timer.c"
	}
}

static void
___lambda49__gtk_widget_destroy (GtkWidget* _sender,
                                 gpointer self)
{
#line 128 "../src/timer.vala"
	__lambda49_ ((ClocksTimerFace*) self);
#line 688 "timer.c"
}

ClocksTimerFace*
clocks_timer_face_construct (GType object_type,
                             ClocksHeaderBar* header_bar)
{
	ClocksTimerFace * self = NULL;
	GSettings* _tmp0_;
	GTimer* _tmp1_;
	ClocksUtilsBell* _tmp2_;
	GNotification* _tmp3_;
	GNotification* _tmp4_;
	GtkGrid* _tmp5_;
	GtkGrid* _tmp6_;
#line 115 "../src/timer.vala"
	g_return_val_if_fail (header_bar != NULL, NULL);
#line 116 "../src/timer.vala"
	self = (ClocksTimerFace*) g_object_new (object_type, "label", _ ("Timer"), "icon-name", "timer-symbolic", "header-bar", header_bar, "panel-id", CLOCKS_PANEL_ID_TIMER, "transition-type", GTK_STACK_TRANSITION_TYPE_CROSSFADE, NULL);
#line 122 "../src/timer.vala"
	_tmp0_ = g_settings_new ("org.gnome.clocks");
#line 122 "../src/timer.vala"
	_g_object_unref0 (self->priv->settings);
#line 122 "../src/timer.vala"
	self->priv->settings = _tmp0_;
#line 124 "../src/timer.vala"
	self->priv->span = (gdouble) 0;
#line 125 "../src/timer.vala"
	_tmp1_ = g_timer_new ();
#line 125 "../src/timer.vala"
	_g_timer_destroy0 (self->priv->timer);
#line 125 "../src/timer.vala"
	self->priv->timer = _tmp1_;
#line 127 "../src/timer.vala"
	self->priv->timeout_id = (guint) 0;
#line 128 "../src/timer.vala"
	g_signal_connect_object ((GtkWidget*) self, "destroy", (GCallback) ___lambda49__gtk_widget_destroy, self, 0);
#line 135 "../src/timer.vala"
	_tmp2_ = clocks_utils_bell_new ("complete");
#line 135 "../src/timer.vala"
	_g_object_unref0 (self->priv->bell);
#line 135 "../src/timer.vala"
	self->priv->bell = _tmp2_;
#line 136 "../src/timer.vala"
	_tmp3_ = g_notification_new (_ ("Time is up!"));
#line 136 "../src/timer.vala"
	_g_object_unref0 (self->priv->notification);
#line 136 "../src/timer.vala"
	self->priv->notification = _tmp3_;
#line 137 "../src/timer.vala"
	_tmp4_ = self->priv->notification;
#line 137 "../src/timer.vala"
	g_notification_set_body (_tmp4_, _ ("Timer countdown finished"));
#line 140 "../src/timer.vala"
	_tmp5_ = self->priv->grid_spinbuttons;
#line 140 "../src/timer.vala"
	gtk_widget_set_direction ((GtkWidget*) _tmp5_, GTK_TEXT_DIR_LTR);
#line 141 "../src/timer.vala"
	_tmp6_ = self->priv->grid_labels;
#line 141 "../src/timer.vala"
	gtk_widget_set_direction ((GtkWidget*) _tmp6_, GTK_TEXT_DIR_LTR);
#line 143 "../src/timer.vala"
	clocks_timer_face_reset (self);
#line 115 "../src/timer.vala"
	return self;
#line 753 "timer.c"
}

ClocksTimerFace*
clocks_timer_face_new (ClocksHeaderBar* header_bar)
{
#line 115 "../src/timer.vala"
	return clocks_timer_face_construct (CLOCKS_TIMER_TYPE_FACE, header_bar);
#line 761 "timer.c"
}

static gboolean
clocks_timer_face_show_leading_zeros (ClocksTimerFace* self,
                                      GtkSpinButton* spin_button)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gboolean result = FALSE;
#line 153 "../src/timer.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 153 "../src/timer.vala"
	g_return_val_if_fail (spin_button != NULL, FALSE);
#line 154 "../src/timer.vala"
	_tmp0_ = g_strdup_printf ("%02i", gtk_spin_button_get_value_as_int (spin_button));
#line 154 "../src/timer.vala"
	_tmp1_ = _tmp0_;
#line 154 "../src/timer.vala"
	gtk_entry_set_text ((GtkEntry*) spin_button, _tmp1_);
#line 154 "../src/timer.vala"
	_g_free0 (_tmp1_);
#line 155 "../src/timer.vala"
	result = TRUE;
#line 155 "../src/timer.vala"
	return result;
#line 787 "timer.c"
}

static gboolean
_clocks_timer_face_show_leading_zeros_gtk_spin_button_output (GtkSpinButton* _sender,
                                                              gpointer self)
{
	gboolean result;
	result = clocks_timer_face_show_leading_zeros ((ClocksTimerFace*) self, _sender);
#line 67 "../src/timer.vala"
	return result;
#line 798 "timer.c"
}

static gint
clocks_timer_face_input_minutes (ClocksTimerFace* self,
                                 GtkSpinButton* spin_button,
                                 gdouble* new_value)
{
	gdouble _vala_new_value = 0.0;
	gint entered_value = 0;
	const gchar* _tmp0_;
	gint result = 0;
#line 159 "../src/timer.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 159 "../src/timer.vala"
	g_return_val_if_fail (spin_button != NULL, 0);
#line 160 "../src/timer.vala"
	_tmp0_ = gtk_entry_get_text ((GtkEntry*) spin_button);
#line 160 "../src/timer.vala"
	entered_value = atoi (_tmp0_);
#line 164 "../src/timer.vala"
	if (entered_value > 59) {
#line 820 "timer.c"
		gint current_hours = 0;
		GtkSpinButton* _tmp1_;
		GtkSpinButton* _tmp2_;
#line 165 "../src/timer.vala"
		_tmp1_ = self->priv->h_spinbutton;
#line 165 "../src/timer.vala"
		current_hours = gtk_spin_button_get_value_as_int (_tmp1_);
#line 166 "../src/timer.vala"
		_tmp2_ = self->priv->h_spinbutton;
#line 166 "../src/timer.vala"
		gtk_spin_button_set_value (_tmp2_, MIN ((gdouble) 99, (gdouble) (current_hours + (entered_value / 60))));
#line 832 "timer.c"
	}
#line 168 "../src/timer.vala"
	_vala_new_value = (gdouble) (entered_value % 60);
#line 169 "../src/timer.vala"
	result = 1;
#line 169 "../src/timer.vala"
	if (new_value) {
#line 169 "../src/timer.vala"
		*new_value = _vala_new_value;
#line 842 "timer.c"
	}
#line 169 "../src/timer.vala"
	return result;
#line 846 "timer.c"
}

static gint
_clocks_timer_face_input_minutes_gtk_spin_button_input (GtkSpinButton* _sender,
                                                        gdouble* new_value,
                                                        gpointer self)
{
	gint result;
	result = clocks_timer_face_input_minutes ((ClocksTimerFace*) self, _sender, new_value);
#line 67 "../src/timer.vala"
	return result;
#line 858 "timer.c"
}

static gint
clocks_timer_face_input_seconds (ClocksTimerFace* self,
                                 GtkSpinButton* spin_button,
                                 gdouble* new_value)
{
	gdouble _vala_new_value = 0.0;
	gint entered_value = 0;
	const gchar* _tmp0_;
	gint result = 0;
#line 173 "../src/timer.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 173 "../src/timer.vala"
	g_return_val_if_fail (spin_button != NULL, 0);
#line 174 "../src/timer.vala"
	_tmp0_ = gtk_entry_get_text ((GtkEntry*) spin_button);
#line 174 "../src/timer.vala"
	entered_value = atoi (_tmp0_);
#line 178 "../src/timer.vala"
	if (entered_value > 59) {
#line 880 "timer.c"
		gint current_minutes = 0;
		GtkSpinButton* _tmp1_;
		gint new_minutes = 0;
		GtkSpinButton* _tmp4_;
#line 179 "../src/timer.vala"
		_tmp1_ = self->priv->m_spinbutton;
#line 179 "../src/timer.vala"
		current_minutes = gtk_spin_button_get_value_as_int (_tmp1_);
#line 180 "../src/timer.vala"
		new_minutes = current_minutes + (entered_value / 60);
#line 181 "../src/timer.vala"
		if (new_minutes > 59) {
#line 893 "timer.c"
			gint current_hours = 0;
			GtkSpinButton* _tmp2_;
			GtkSpinButton* _tmp3_;
#line 182 "../src/timer.vala"
			_tmp2_ = self->priv->h_spinbutton;
#line 182 "../src/timer.vala"
			current_hours = gtk_spin_button_get_value_as_int (_tmp2_);
#line 183 "../src/timer.vala"
			_tmp3_ = self->priv->h_spinbutton;
#line 183 "../src/timer.vala"
			gtk_spin_button_set_value (_tmp3_, MIN ((gdouble) 99, (gdouble) (current_hours + (new_minutes / 60))));
#line 184 "../src/timer.vala"
			new_minutes = new_minutes % 60;
#line 907 "timer.c"
		}
#line 186 "../src/timer.vala"
		_tmp4_ = self->priv->m_spinbutton;
#line 186 "../src/timer.vala"
		gtk_spin_button_set_value (_tmp4_, (gdouble) new_minutes);
#line 913 "timer.c"
	}
#line 188 "../src/timer.vala"
	_vala_new_value = (gdouble) (entered_value % 60);
#line 189 "../src/timer.vala"
	result = 1;
#line 189 "../src/timer.vala"
	if (new_value) {
#line 189 "../src/timer.vala"
		*new_value = _vala_new_value;
#line 923 "timer.c"
	}
#line 189 "../src/timer.vala"
	return result;
#line 927 "timer.c"
}

static gint
_clocks_timer_face_input_seconds_gtk_spin_button_input (GtkSpinButton* _sender,
                                                        gdouble* new_value,
                                                        gpointer self)
{
	gint result;
	result = clocks_timer_face_input_seconds ((ClocksTimerFace*) self, _sender, new_value);
#line 67 "../src/timer.vala"
	return result;
#line 939 "timer.c"
}

static void
clocks_timer_face_update_start_button (ClocksTimerFace* self)
{
	gint h = 0;
	GtkSpinButton* _tmp0_;
	gint m = 0;
	GtkSpinButton* _tmp1_;
	gint s = 0;
	GtkSpinButton* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
#line 193 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 194 "../src/timer.vala"
	_tmp0_ = self->priv->h_spinbutton;
#line 194 "../src/timer.vala"
	h = gtk_spin_button_get_value_as_int (_tmp0_);
#line 195 "../src/timer.vala"
	_tmp1_ = self->priv->m_spinbutton;
#line 195 "../src/timer.vala"
	m = gtk_spin_button_get_value_as_int (_tmp1_);
#line 196 "../src/timer.vala"
	_tmp2_ = self->priv->s_spinbutton;
#line 196 "../src/timer.vala"
	s = gtk_spin_button_get_value_as_int (_tmp2_);
#line 198 "../src/timer.vala"
	if (h != 0) {
#line 198 "../src/timer.vala"
		_tmp4_ = TRUE;
#line 971 "timer.c"
	} else {
#line 198 "../src/timer.vala"
		_tmp4_ = m != 0;
#line 975 "timer.c"
	}
#line 198 "../src/timer.vala"
	if (_tmp4_) {
#line 198 "../src/timer.vala"
		_tmp3_ = TRUE;
#line 981 "timer.c"
	} else {
#line 198 "../src/timer.vala"
		_tmp3_ = s != 0;
#line 985 "timer.c"
	}
#line 198 "../src/timer.vala"
	if (_tmp3_) {
#line 989 "timer.c"
		GtkButton* _tmp5_;
		GtkButton* _tmp6_;
		GtkStyleContext* _tmp7_;
#line 199 "../src/timer.vala"
		_tmp5_ = self->priv->start_button;
#line 199 "../src/timer.vala"
		gtk_widget_set_sensitive ((GtkWidget*) _tmp5_, TRUE);
#line 200 "../src/timer.vala"
		_tmp6_ = self->priv->start_button;
#line 200 "../src/timer.vala"
		_tmp7_ = gtk_widget_get_style_context ((GtkWidget*) _tmp6_);
#line 200 "../src/timer.vala"
		gtk_style_context_add_class (_tmp7_, "suggested-action");
#line 1003 "timer.c"
	} else {
		GtkButton* _tmp8_;
		GtkButton* _tmp9_;
		GtkStyleContext* _tmp10_;
#line 202 "../src/timer.vala"
		_tmp8_ = self->priv->start_button;
#line 202 "../src/timer.vala"
		gtk_widget_set_sensitive ((GtkWidget*) _tmp8_, FALSE);
#line 203 "../src/timer.vala"
		_tmp9_ = self->priv->start_button;
#line 203 "../src/timer.vala"
		_tmp10_ = gtk_widget_get_style_context ((GtkWidget*) _tmp9_);
#line 203 "../src/timer.vala"
		gtk_style_context_remove_class (_tmp10_, "suggested-action");
#line 1018 "timer.c"
	}
}

static void
_clocks_timer_face_update_start_button_gtk_editable_changed (GtkEditable* _sender,
                                                             gpointer self)
{
#line 67 "../src/timer.vala"
	clocks_timer_face_update_start_button ((ClocksTimerFace*) self);
#line 1028 "timer.c"
}

static void
clocks_timer_face_on_start_button_clicked (ClocksTimerFace* self)
{
#line 208 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 209 "../src/timer.vala"
	clocks_timer_face_start (self);
#line 1038 "timer.c"
}

static void
_clocks_timer_face_on_start_button_clicked_gtk_button_clicked (GtkButton* _sender,
                                                               gpointer self)
{
#line 67 "../src/timer.vala"
	clocks_timer_face_on_start_button_clicked ((ClocksTimerFace*) self);
#line 1047 "timer.c"
}

static void
clocks_timer_face_on_left_button_clicked (ClocksTimerFace* self)
{
	ClocksTimerFaceState _tmp0_;
#line 213 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 214 "../src/timer.vala"
	_tmp0_ = self->priv->_state;
#line 214 "../src/timer.vala"
	switch (_tmp0_) {
#line 214 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_STATE_RUNNING:
#line 1062 "timer.c"
		{
			GtkButton* _tmp1_;
			GtkButton* _tmp2_;
			GtkStyleContext* _tmp3_;
#line 216 "../src/timer.vala"
			clocks_timer_face_pause (self);
#line 217 "../src/timer.vala"
			_tmp1_ = self->priv->left_button;
#line 217 "../src/timer.vala"
			gtk_button_set_label (_tmp1_, _ ("Continue"));
#line 218 "../src/timer.vala"
			_tmp2_ = self->priv->left_button;
#line 218 "../src/timer.vala"
			_tmp3_ = gtk_widget_get_style_context ((GtkWidget*) _tmp2_);
#line 218 "../src/timer.vala"
			gtk_style_context_add_class (_tmp3_, "suggested-action");
#line 219 "../src/timer.vala"
			break;
#line 1081 "timer.c"
		}
#line 214 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_STATE_PAUSED:
#line 1085 "timer.c"
		{
			GtkButton* _tmp4_;
			GtkButton* _tmp5_;
			GtkStyleContext* _tmp6_;
#line 221 "../src/timer.vala"
			clocks_timer_face_start (self);
#line 222 "../src/timer.vala"
			_tmp4_ = self->priv->left_button;
#line 222 "../src/timer.vala"
			gtk_button_set_label (_tmp4_, _ ("Pause"));
#line 223 "../src/timer.vala"
			_tmp5_ = self->priv->left_button;
#line 223 "../src/timer.vala"
			_tmp6_ = gtk_widget_get_style_context ((GtkWidget*) _tmp5_);
#line 223 "../src/timer.vala"
			gtk_style_context_remove_class (_tmp6_, "suggested-action");
#line 224 "../src/timer.vala"
			break;
#line 1104 "timer.c"
		}
		default:
		{
#line 226 "../src/timer.vala"
			g_assert_not_reached ();
#line 1110 "timer.c"
		}
	}
}

static void
_clocks_timer_face_on_left_button_clicked_gtk_button_clicked (GtkButton* _sender,
                                                              gpointer self)
{
#line 67 "../src/timer.vala"
	clocks_timer_face_on_left_button_clicked ((ClocksTimerFace*) self);
#line 1121 "timer.c"
}

static void
clocks_timer_face_on_right_button_clicked (ClocksTimerFace* self)
{
	GtkButton* _tmp0_;
#line 231 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 232 "../src/timer.vala"
	clocks_timer_face_reset (self);
#line 233 "../src/timer.vala"
	_tmp0_ = self->priv->left_button;
#line 233 "../src/timer.vala"
	gtk_button_set_label (_tmp0_, _ ("Pause"));
#line 1136 "timer.c"
}

static void
_clocks_timer_face_on_right_button_clicked_gtk_button_clicked (GtkButton* _sender,
                                                               gpointer self)
{
#line 67 "../src/timer.vala"
	clocks_timer_face_on_right_button_clicked ((ClocksTimerFace*) self);
#line 1145 "timer.c"
}

static void
clocks_timer_face_reset (ClocksTimerFace* self)
{
	GTimer* _tmp0_;
	GSettings* _tmp1_;
	GtkSpinButton* _tmp2_;
	GtkSpinButton* _tmp3_;
	GtkSpinButton* _tmp4_;
	GtkButton* _tmp5_;
	GtkStyleContext* _tmp6_;
	ClocksTimerCountdownFrame* _tmp7_;
	GtkStyleContext* _tmp8_;
	GtkButton* _tmp9_;
	ClocksTimerCountdownFrame* _tmp10_;
	ClocksAnalogFrame* _tmp11_;
#line 236 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 237 "../src/timer.vala"
	clocks_timer_face_set_state (self, CLOCKS_TIMER_FACE_STATE_STOPPED);
#line 238 "../src/timer.vala"
	_tmp0_ = self->priv->timer;
#line 238 "../src/timer.vala"
	g_timer_reset (_tmp0_);
#line 239 "../src/timer.vala"
	_tmp1_ = self->priv->settings;
#line 239 "../src/timer.vala"
	self->priv->span = (gdouble) g_settings_get_uint (_tmp1_, "timer");
#line 240 "../src/timer.vala"
	_tmp2_ = self->priv->h_spinbutton;
#line 240 "../src/timer.vala"
	gtk_spin_button_set_value (_tmp2_, (gdouble) (((gint) self->priv->span) / 3600));
#line 241 "../src/timer.vala"
	_tmp3_ = self->priv->m_spinbutton;
#line 241 "../src/timer.vala"
	gtk_spin_button_set_value (_tmp3_, (gdouble) ((((gint) self->priv->span) % 3600) / 60));
#line 242 "../src/timer.vala"
	_tmp4_ = self->priv->s_spinbutton;
#line 242 "../src/timer.vala"
	gtk_spin_button_set_value (_tmp4_, fmod (self->priv->span, 60));
#line 243 "../src/timer.vala"
	_tmp5_ = self->priv->left_button;
#line 243 "../src/timer.vala"
	_tmp6_ = gtk_widget_get_style_context ((GtkWidget*) _tmp5_);
#line 243 "../src/timer.vala"
	gtk_style_context_remove_class (_tmp6_, "clocks-go");
#line 244 "../src/timer.vala"
	_tmp7_ = self->priv->countdown_frame;
#line 244 "../src/timer.vala"
	_tmp8_ = gtk_widget_get_style_context ((GtkWidget*) _tmp7_);
#line 244 "../src/timer.vala"
	gtk_style_context_remove_class (_tmp8_, "clocks-paused");
#line 245 "../src/timer.vala"
	_tmp9_ = self->priv->start_button;
#line 245 "../src/timer.vala"
	gtk_widget_set_sensitive ((GtkWidget*) _tmp9_, self->priv->span > ((gdouble) 0));
#line 246 "../src/timer.vala"
	_tmp10_ = self->priv->countdown_frame;
#line 246 "../src/timer.vala"
	clocks_timer_countdown_frame_reset (_tmp10_);
#line 247 "../src/timer.vala"
	_tmp11_ = self->priv->setup_frame;
#line 247 "../src/timer.vala"
	gtk_stack_set_visible_child ((GtkStack*) self, (GtkWidget*) _tmp11_);
#line 1211 "timer.c"
}

static gboolean
__lambda50_ (ClocksTimerFace* self)
{
	ClocksTimerFaceState _tmp0_;
	gdouble e = 0.0;
	GTimer* _tmp1_;
	gboolean result = FALSE;
#line 269 "../src/timer.vala"
	_tmp0_ = self->priv->_state;
#line 269 "../src/timer.vala"
	if (_tmp0_ != CLOCKS_TIMER_FACE_STATE_RUNNING) {
#line 270 "../src/timer.vala"
		self->priv->timeout_id = (guint) 0;
#line 271 "../src/timer.vala"
		result = FALSE;
#line 271 "../src/timer.vala"
		return result;
#line 1231 "timer.c"
	}
#line 273 "../src/timer.vala"
	_tmp1_ = self->priv->timer;
#line 273 "../src/timer.vala"
	e = g_timer_elapsed (_tmp1_, NULL);
#line 274 "../src/timer.vala"
	if (e >= self->priv->span) {
#line 275 "../src/timer.vala"
		clocks_timer_face_reset (self);
#line 276 "../src/timer.vala"
		g_signal_emit (self, clocks_timer_face_signals[CLOCKS_TIMER_FACE_RING_SIGNAL], 0);
#line 277 "../src/timer.vala"
		self->priv->timeout_id = (guint) 0;
#line 278 "../src/timer.vala"
		result = FALSE;
#line 278 "../src/timer.vala"
		return result;
#line 1249 "timer.c"
	}
#line 280 "../src/timer.vala"
	clocks_timer_face_update_countdown (self, e);
#line 281 "../src/timer.vala"
	result = TRUE;
#line 281 "../src/timer.vala"
	return result;
#line 1257 "timer.c"
}

static gboolean
___lambda50__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda50_ ((ClocksTimerFace*) self);
#line 268 "../src/timer.vala"
	return result;
#line 1267 "timer.c"
}

static void
clocks_timer_face_start (ClocksTimerFace* self)
{
	ClocksTimerCountdownFrame* _tmp0_;
	GtkStyleContext* _tmp1_;
	ClocksTimerFaceState _tmp2_;
	GTimer* _tmp9_;
#line 250 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 251 "../src/timer.vala"
	_tmp0_ = self->priv->countdown_frame;
#line 251 "../src/timer.vala"
	_tmp1_ = gtk_widget_get_style_context ((GtkWidget*) _tmp0_);
#line 251 "../src/timer.vala"
	gtk_style_context_remove_class (_tmp1_, "clocks-paused");
#line 253 "../src/timer.vala"
	_tmp2_ = self->priv->_state;
#line 253 "../src/timer.vala"
	if (_tmp2_ == CLOCKS_TIMER_FACE_STATE_STOPPED) {
#line 1289 "timer.c"
		gint h = 0;
		GtkSpinButton* _tmp3_;
		gint m = 0;
		GtkSpinButton* _tmp4_;
		gint s = 0;
		GtkSpinButton* _tmp5_;
		GSettings* _tmp6_;
		ClocksTimerCountdownFrame* _tmp7_;
		ClocksTimerCountdownFrame* _tmp8_;
#line 254 "../src/timer.vala"
		_tmp3_ = self->priv->h_spinbutton;
#line 254 "../src/timer.vala"
		h = gtk_spin_button_get_value_as_int (_tmp3_);
#line 255 "../src/timer.vala"
		_tmp4_ = self->priv->m_spinbutton;
#line 255 "../src/timer.vala"
		m = gtk_spin_button_get_value_as_int (_tmp4_);
#line 256 "../src/timer.vala"
		_tmp5_ = self->priv->s_spinbutton;
#line 256 "../src/timer.vala"
		s = gtk_spin_button_get_value_as_int (_tmp5_);
#line 258 "../src/timer.vala"
		self->priv->span = (gdouble) (((h * 3600) + (m * 60)) + s);
#line 259 "../src/timer.vala"
		_tmp6_ = self->priv->settings;
#line 259 "../src/timer.vala"
		g_settings_set_uint (_tmp6_, "timer", (guint) self->priv->span);
#line 260 "../src/timer.vala"
		_tmp7_ = self->priv->countdown_frame;
#line 260 "../src/timer.vala"
		clocks_timer_countdown_frame_set_span (_tmp7_, self->priv->span);
#line 261 "../src/timer.vala"
		_tmp8_ = self->priv->countdown_frame;
#line 261 "../src/timer.vala"
		gtk_stack_set_visible_child ((GtkStack*) self, (GtkWidget*) _tmp8_);
#line 263 "../src/timer.vala"
		clocks_timer_face_update_countdown_label (self, h, m, s);
#line 1327 "timer.c"
	}
#line 266 "../src/timer.vala"
	clocks_timer_face_set_state (self, CLOCKS_TIMER_FACE_STATE_RUNNING);
#line 267 "../src/timer.vala"
	_tmp9_ = self->priv->timer;
#line 267 "../src/timer.vala"
	g_timer_start (_tmp9_);
#line 268 "../src/timer.vala"
	self->priv->timeout_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 40, ___lambda50__gsource_func, g_object_ref (self), g_object_unref);
#line 1337 "timer.c"
}

static void
clocks_timer_face_pause (ClocksTimerFace* self)
{
	GTimer* _tmp0_;
	GTimer* _tmp1_;
	ClocksTimerCountdownFrame* _tmp2_;
	GtkStyleContext* _tmp3_;
	ClocksTimerCountdownFrame* _tmp4_;
#line 285 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 286 "../src/timer.vala"
	clocks_timer_face_set_state (self, CLOCKS_TIMER_FACE_STATE_PAUSED);
#line 287 "../src/timer.vala"
	_tmp0_ = self->priv->timer;
#line 287 "../src/timer.vala"
	g_timer_stop (_tmp0_);
#line 288 "../src/timer.vala"
	_tmp1_ = self->priv->timer;
#line 288 "../src/timer.vala"
	self->priv->span = self->priv->span - g_timer_elapsed (_tmp1_, NULL);
#line 289 "../src/timer.vala"
	_tmp2_ = self->priv->countdown_frame;
#line 289 "../src/timer.vala"
	_tmp3_ = gtk_widget_get_style_context ((GtkWidget*) _tmp2_);
#line 289 "../src/timer.vala"
	gtk_style_context_add_class (_tmp3_, "clocks-paused");
#line 290 "../src/timer.vala"
	_tmp4_ = self->priv->countdown_frame;
#line 290 "../src/timer.vala"
	clocks_timer_countdown_frame_pause (_tmp4_);
#line 1370 "timer.c"
}

static void
clocks_timer_face_update_countdown (ClocksTimerFace* self,
                                    gdouble elapsed)
{
	GtkSpinButton* _tmp0_;
#line 293 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 294 "../src/timer.vala"
	_tmp0_ = self->priv->h_label;
#line 294 "../src/timer.vala"
	if (gtk_widget_get_mapped ((GtkWidget*) _tmp0_)) {
#line 1384 "timer.c"
		gdouble t = 0.0;
		gint h = 0;
		gint m = 0;
		gint s = 0;
		gdouble r = 0.0;
		gint _tmp1_ = 0;
		gint _tmp2_ = 0;
		gint _tmp3_ = 0;
		gdouble _tmp4_ = 0.0;
		ClocksTimerCountdownFrame* _tmp5_;
#line 298 "../src/timer.vala"
		t = ceil (self->priv->span - elapsed);
#line 303 "../src/timer.vala"
		clocks_utils_time_to_hms (t, &_tmp1_, &_tmp2_, &_tmp3_, &_tmp4_);
#line 303 "../src/timer.vala"
		h = _tmp1_;
#line 303 "../src/timer.vala"
		m = _tmp2_;
#line 303 "../src/timer.vala"
		s = _tmp3_;
#line 303 "../src/timer.vala"
		r = _tmp4_;
#line 304 "../src/timer.vala"
		clocks_timer_face_update_countdown_label (self, h, m, s);
#line 305 "../src/timer.vala"
		_tmp5_ = self->priv->countdown_frame;
#line 305 "../src/timer.vala"
		clocks_timer_countdown_frame_update (_tmp5_, elapsed);
#line 1413 "timer.c"
	}
}

static void
clocks_timer_face_update_countdown_label (ClocksTimerFace* self,
                                          gint h,
                                          gint m,
                                          gint s)
{
	GtkSpinButton* _tmp0_;
	GtkSpinButton* _tmp1_;
	GtkSpinButton* _tmp2_;
#line 309 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 310 "../src/timer.vala"
	_tmp0_ = self->priv->h_label;
#line 310 "../src/timer.vala"
	gtk_spin_button_set_value (_tmp0_, (gdouble) h);
#line 311 "../src/timer.vala"
	_tmp1_ = self->priv->m_label;
#line 311 "../src/timer.vala"
	gtk_spin_button_set_value (_tmp1_, (gdouble) m);
#line 312 "../src/timer.vala"
	_tmp2_ = self->priv->s_label;
#line 312 "../src/timer.vala"
	gtk_spin_button_set_value (_tmp2_, (gdouble) s);
#line 1440 "timer.c"
}

static void
clocks_timer_face_real_grab_focus (GtkWidget* base)
{
	ClocksTimerFace * self;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	ClocksAnalogFrame* _tmp2_;
#line 315 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 316 "../src/timer.vala"
	_tmp0_ = gtk_stack_get_visible_child ((GtkStack*) self);
#line 316 "../src/timer.vala"
	_tmp1_ = _tmp0_;
#line 316 "../src/timer.vala"
	_tmp2_ = self->priv->setup_frame;
#line 316 "../src/timer.vala"
	if (_tmp1_ == G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, gtk_widget_get_type (), GtkWidget)) {
#line 1460 "timer.c"
		GtkButton* _tmp3_;
#line 317 "../src/timer.vala"
		_tmp3_ = self->priv->start_button;
#line 317 "../src/timer.vala"
		gtk_widget_grab_focus ((GtkWidget*) _tmp3_);
#line 1466 "timer.c"
	}
}

static gboolean
clocks_timer_face_real_escape_pressed (ClocksClock* base)
{
	ClocksTimerFace * self;
	ClocksTimerFaceState _tmp0_;
	gboolean result = FALSE;
#line 321 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 322 "../src/timer.vala"
	_tmp0_ = self->priv->_state;
#line 322 "../src/timer.vala"
	if (_tmp0_ == CLOCKS_TIMER_FACE_STATE_STOPPED) {
#line 323 "../src/timer.vala"
		result = FALSE;
#line 323 "../src/timer.vala"
		return result;
#line 1486 "timer.c"
	}
#line 326 "../src/timer.vala"
	clocks_timer_face_reset (self);
#line 328 "../src/timer.vala"
	result = TRUE;
#line 328 "../src/timer.vala"
	return result;
#line 1494 "timer.c"
}

static const gchar*
clocks_timer_face_real_get_label (ClocksClock* base)
{
	const gchar* result;
	ClocksTimerFace* self;
	const gchar* _tmp0_;
#line 74 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 74 "../src/timer.vala"
	_tmp0_ = self->priv->_label;
#line 74 "../src/timer.vala"
	result = _tmp0_;
#line 74 "../src/timer.vala"
	return result;
#line 1511 "timer.c"
}

static void
clocks_timer_face_real_set_label (ClocksClock* base,
                                  const gchar* value)
{
	ClocksTimerFace* self;
#line 74 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 74 "../src/timer.vala"
	if (g_strcmp0 (value, clocks_timer_face_real_get_label (base)) != 0) {
#line 1523 "timer.c"
		gchar* _tmp0_;
#line 74 "../src/timer.vala"
		_tmp0_ = g_strdup (value);
#line 74 "../src/timer.vala"
		_g_free0 (self->priv->_label);
#line 74 "../src/timer.vala"
		self->priv->_label = _tmp0_;
#line 74 "../src/timer.vala"
		g_object_notify_by_pspec ((GObject *) self, clocks_timer_face_properties[CLOCKS_TIMER_FACE_LABEL_PROPERTY]);
#line 1533 "timer.c"
	}
}

static const gchar*
clocks_timer_face_real_get_icon_name (ClocksClock* base)
{
	const gchar* result;
	ClocksTimerFace* self;
	const gchar* _tmp0_;
#line 75 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 75 "../src/timer.vala"
	_tmp0_ = self->priv->_icon_name;
#line 75 "../src/timer.vala"
	result = _tmp0_;
#line 75 "../src/timer.vala"
	return result;
#line 1551 "timer.c"
}

static void
clocks_timer_face_real_set_icon_name (ClocksClock* base,
                                      const gchar* value)
{
	ClocksTimerFace* self;
#line 75 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 75 "../src/timer.vala"
	if (g_strcmp0 (value, clocks_timer_face_real_get_icon_name (base)) != 0) {
#line 1563 "timer.c"
		gchar* _tmp0_;
#line 75 "../src/timer.vala"
		_tmp0_ = g_strdup (value);
#line 75 "../src/timer.vala"
		_g_free0 (self->priv->_icon_name);
#line 75 "../src/timer.vala"
		self->priv->_icon_name = _tmp0_;
#line 75 "../src/timer.vala"
		g_object_notify_by_pspec ((GObject *) self, clocks_timer_face_properties[CLOCKS_TIMER_FACE_ICON_NAME_PROPERTY]);
#line 1573 "timer.c"
	}
}

static ClocksHeaderBar*
clocks_timer_face_real_get_header_bar (ClocksClock* base)
{
	ClocksHeaderBar* result;
	ClocksTimerFace* self;
	ClocksHeaderBar* _tmp0_;
#line 76 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 76 "../src/timer.vala"
	_tmp0_ = self->priv->_header_bar;
#line 76 "../src/timer.vala"
	result = _tmp0_;
#line 76 "../src/timer.vala"
	return result;
#line 1591 "timer.c"
}

static void
clocks_timer_face_real_set_header_bar (ClocksClock* base,
                                       ClocksHeaderBar* value)
{
	ClocksTimerFace* self;
#line 76 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 76 "../src/timer.vala"
	if (clocks_timer_face_real_get_header_bar (base) != value) {
#line 1603 "timer.c"
		ClocksHeaderBar* _tmp0_;
#line 76 "../src/timer.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 76 "../src/timer.vala"
		_g_object_unref0 (self->priv->_header_bar);
#line 76 "../src/timer.vala"
		self->priv->_header_bar = _tmp0_;
#line 76 "../src/timer.vala"
		g_object_notify_by_pspec ((GObject *) self, clocks_timer_face_properties[CLOCKS_TIMER_FACE_HEADER_BAR_PROPERTY]);
#line 1613 "timer.c"
	}
}

static ClocksPanelId
clocks_timer_face_real_get_panel_id (ClocksClock* base)
{
	ClocksPanelId result;
	ClocksTimerFace* self;
	ClocksPanelId _tmp0_;
#line 77 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 77 "../src/timer.vala"
	_tmp0_ = self->priv->_panel_id;
#line 77 "../src/timer.vala"
	result = _tmp0_;
#line 77 "../src/timer.vala"
	return result;
#line 1631 "timer.c"
}

static void
clocks_timer_face_real_set_panel_id (ClocksClock* base,
                                     ClocksPanelId value)
{
	ClocksTimerFace* self;
#line 77 "../src/timer.vala"
	self = (ClocksTimerFace*) base;
#line 77 "../src/timer.vala"
	if (clocks_timer_face_real_get_panel_id (base) != value) {
#line 77 "../src/timer.vala"
		self->priv->_panel_id = value;
#line 77 "../src/timer.vala"
		g_object_notify_by_pspec ((GObject *) self, clocks_timer_face_properties[CLOCKS_TIMER_FACE_PANEL_ID_PROPERTY]);
#line 1647 "timer.c"
	}
}

ClocksTimerFaceState
clocks_timer_face_get_state (ClocksTimerFace* self)
{
	ClocksTimerFaceState result;
	ClocksTimerFaceState _tmp0_;
#line 79 "../src/timer.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 79 "../src/timer.vala"
	_tmp0_ = self->priv->_state;
#line 79 "../src/timer.vala"
	result = _tmp0_;
#line 79 "../src/timer.vala"
	return result;
#line 1664 "timer.c"
}

static void
clocks_timer_face_set_state (ClocksTimerFace* self,
                             ClocksTimerFaceState value)
{
#line 79 "../src/timer.vala"
	g_return_if_fail (self != NULL);
#line 79 "../src/timer.vala"
	if (clocks_timer_face_get_state (self) != value) {
#line 79 "../src/timer.vala"
		self->priv->_state = value;
#line 79 "../src/timer.vala"
		g_object_notify_by_pspec ((GObject *) self, clocks_timer_face_properties[CLOCKS_TIMER_FACE_STATE_PROPERTY]);
#line 1679 "timer.c"
	}
}

static void
clocks_timer_face_real_ring (ClocksTimerFace* self)
{
	ClocksApplication* app = NULL;
	GApplication* _tmp0_;
	ClocksApplication* _tmp1_;
	GNotification* _tmp2_;
	ClocksUtilsBell* _tmp3_;
#line 147 "../src/timer.vala"
	_tmp0_ = g_application_get_default ();
#line 147 "../src/timer.vala"
	_tmp1_ = _g_object_ref0 (CLOCKS_IS_APPLICATION (_tmp0_) ? ((ClocksApplication*) _tmp0_) : NULL);
#line 147 "../src/timer.vala"
	app = _tmp1_;
#line 148 "../src/timer.vala"
	_tmp2_ = self->priv->notification;
#line 148 "../src/timer.vala"
	clocks_application_send_notification (app, "timer-is-up", _tmp2_);
#line 149 "../src/timer.vala"
	_tmp3_ = self->priv->bell;
#line 149 "../src/timer.vala"
	clocks_utils_bell_ring_once (_tmp3_);
#line 146 "../src/timer.vala"
	_g_object_unref0 (app);
#line 1707 "timer.c"
}

static void
clocks_timer_face_class_init (ClocksTimerFaceClass * klass,
                              gpointer klass_data)
{
#line 67 "../src/timer.vala"
	clocks_timer_face_parent_class = g_type_class_peek_parent (klass);
#line 67 "../src/timer.vala"
	g_type_class_adjust_private_offset (klass, &ClocksTimerFace_private_offset);
#line 67 "../src/timer.vala"
	((GtkWidgetClass *) klass)->grab_focus = (void (*) (GtkWidget*)) clocks_timer_face_real_grab_focus;
#line 67 "../src/timer.vala"
	((ClocksTimerFaceClass *) klass)->ring = clocks_timer_face_real_ring;
#line 67 "../src/timer.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_clocks_timer_face_get_property;
#line 67 "../src/timer.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_clocks_timer_face_set_property;
#line 67 "../src/timer.vala"
	G_OBJECT_CLASS (klass)->finalize = clocks_timer_face_finalize;
#line 67 "../src/timer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_TIMER_FACE_LABEL_PROPERTY, clocks_timer_face_properties[CLOCKS_TIMER_FACE_LABEL_PROPERTY] = g_param_spec_string ("label", "label", "label", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
#line 67 "../src/timer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_TIMER_FACE_ICON_NAME_PROPERTY, clocks_timer_face_properties[CLOCKS_TIMER_FACE_ICON_NAME_PROPERTY] = g_param_spec_string ("icon-name", "icon-name", "icon-name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
#line 67 "../src/timer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_TIMER_FACE_HEADER_BAR_PROPERTY, clocks_timer_face_properties[CLOCKS_TIMER_FACE_HEADER_BAR_PROPERTY] = g_param_spec_object ("header-bar", "header-bar", "header-bar", CLOCKS_TYPE_HEADER_BAR, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
#line 67 "../src/timer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_TIMER_FACE_PANEL_ID_PROPERTY, clocks_timer_face_properties[CLOCKS_TIMER_FACE_PANEL_ID_PROPERTY] = g_param_spec_enum ("panel-id", "panel-id", "panel-id", CLOCKS_TYPE_PANEL_ID, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
#line 67 "../src/timer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_TIMER_FACE_STATE_PROPERTY, clocks_timer_face_properties[CLOCKS_TIMER_FACE_STATE_PROPERTY] = g_param_spec_enum ("state", "state", "state", CLOCKS_TIMER_FACE_TYPE_STATE, CLOCKS_TIMER_FACE_STATE_STOPPED, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 67 "../src/timer.vala"
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/org/gnome/clocks/ui/timer.ui");
#line 67 "../src/timer.vala"
	clocks_timer_face_signals[CLOCKS_TIMER_FACE_RING_SIGNAL] = g_signal_new ("ring", CLOCKS_TIMER_TYPE_FACE, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (ClocksTimerFaceClass, ring), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "setup_frame", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, setup_frame));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "grid_spinbuttons", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, grid_spinbuttons));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "grid_labels", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, grid_labels));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "h_spinbutton", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, h_spinbutton));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "m_spinbutton", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, m_spinbutton));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "s_spinbutton", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, s_spinbutton));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "start_button", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, start_button));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "countdown_frame", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, countdown_frame));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "h_label", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, h_label));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "m_label", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, m_label));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "s_label", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, s_label));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "left_button", FALSE, ClocksTimerFace_private_offset + G_STRUCT_OFFSET (ClocksTimerFacePrivate, left_button));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "show_leading_zeros", G_CALLBACK(_clocks_timer_face_show_leading_zeros_gtk_spin_button_output));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "input_minutes", G_CALLBACK(_clocks_timer_face_input_minutes_gtk_spin_button_input));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "input_seconds", G_CALLBACK(_clocks_timer_face_input_seconds_gtk_spin_button_input));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "update_start_button", G_CALLBACK(_clocks_timer_face_update_start_button_gtk_editable_changed));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_start_button_clicked", G_CALLBACK(_clocks_timer_face_on_start_button_clicked_gtk_button_clicked));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_left_button_clicked", G_CALLBACK(_clocks_timer_face_on_left_button_clicked_gtk_button_clicked));
#line 67 "../src/timer.vala"
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_right_button_clicked", G_CALLBACK(_clocks_timer_face_on_right_button_clicked_gtk_button_clicked));
#line 1780 "timer.c"
}

static void
clocks_timer_face_clocks_clock_interface_init (ClocksClockIface * iface,
                                               gpointer iface_data)
{
#line 67 "../src/timer.vala"
	clocks_timer_face_clocks_clock_parent_iface = g_type_interface_peek_parent (iface);
#line 67 "../src/timer.vala"
	iface->escape_pressed = (gboolean (*) (ClocksClock*)) clocks_timer_face_real_escape_pressed;
#line 67 "../src/timer.vala"
	iface->get_label = clocks_timer_face_real_get_label;
#line 67 "../src/timer.vala"
	iface->set_label = clocks_timer_face_real_set_label;
#line 67 "../src/timer.vala"
	iface->get_icon_name = clocks_timer_face_real_get_icon_name;
#line 67 "../src/timer.vala"
	iface->set_icon_name = clocks_timer_face_real_set_icon_name;
#line 67 "../src/timer.vala"
	iface->get_header_bar = clocks_timer_face_real_get_header_bar;
#line 67 "../src/timer.vala"
	iface->set_header_bar = clocks_timer_face_real_set_header_bar;
#line 67 "../src/timer.vala"
	iface->get_panel_id = clocks_timer_face_real_get_panel_id;
#line 67 "../src/timer.vala"
	iface->set_panel_id = clocks_timer_face_real_set_panel_id;
#line 1807 "timer.c"
}

static void
clocks_timer_face_instance_init (ClocksTimerFace * self,
                                 gpointer klass)
{
#line 67 "../src/timer.vala"
	self->priv = clocks_timer_face_get_instance_private (self);
#line 79 "../src/timer.vala"
	self->priv->_state = CLOCKS_TIMER_FACE_STATE_STOPPED;
#line 67 "../src/timer.vala"
	g_type_ensure (CLOCKS_TYPE_ANALOG_FRAME);
#line 67 "../src/timer.vala"
	g_type_ensure (CLOCKS_TIMER_TYPE_COUNTDOWN_FRAME);
#line 67 "../src/timer.vala"
	gtk_widget_init_template (GTK_WIDGET (self));
#line 1824 "timer.c"
}

static void
clocks_timer_face_finalize (GObject * obj)
{
	ClocksTimerFace * self;
#line 67 "../src/timer.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CLOCKS_TIMER_TYPE_FACE, ClocksTimerFace);
#line 74 "../src/timer.vala"
	_g_free0 (self->priv->_label);
#line 75 "../src/timer.vala"
	_g_free0 (self->priv->_icon_name);
#line 76 "../src/timer.vala"
	_g_object_unref0 (self->priv->_header_bar);
#line 81 "../src/timer.vala"
	_g_object_unref0 (self->priv->settings);
#line 83 "../src/timer.vala"
	_g_timer_destroy0 (self->priv->timer);
#line 85 "../src/timer.vala"
	_g_object_unref0 (self->priv->bell);
#line 86 "../src/timer.vala"
	_g_object_unref0 (self->priv->notification);
#line 88 "../src/timer.vala"
	_g_object_unref0 (self->priv->setup_frame);
#line 90 "../src/timer.vala"
	_g_object_unref0 (self->priv->grid_spinbuttons);
#line 92 "../src/timer.vala"
	_g_object_unref0 (self->priv->grid_labels);
#line 94 "../src/timer.vala"
	_g_object_unref0 (self->priv->h_spinbutton);
#line 96 "../src/timer.vala"
	_g_object_unref0 (self->priv->m_spinbutton);
#line 98 "../src/timer.vala"
	_g_object_unref0 (self->priv->s_spinbutton);
#line 100 "../src/timer.vala"
	_g_object_unref0 (self->priv->start_button);
#line 102 "../src/timer.vala"
	_g_object_unref0 (self->priv->countdown_frame);
#line 107 "../src/timer.vala"
	_g_object_unref0 (self->priv->h_label);
#line 109 "../src/timer.vala"
	_g_object_unref0 (self->priv->m_label);
#line 111 "../src/timer.vala"
	_g_object_unref0 (self->priv->s_label);
#line 113 "../src/timer.vala"
	_g_object_unref0 (self->priv->left_button);
#line 67 "../src/timer.vala"
	G_OBJECT_CLASS (clocks_timer_face_parent_class)->finalize (obj);
#line 1873 "timer.c"
}

GType
clocks_timer_face_get_type (void)
{
	static volatile gsize clocks_timer_face_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_timer_face_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClocksTimerFaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) clocks_timer_face_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClocksTimerFace), 0, (GInstanceInitFunc) clocks_timer_face_instance_init, NULL };
		static const GInterfaceInfo clocks_clock_info = { (GInterfaceInitFunc) clocks_timer_face_clocks_clock_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType clocks_timer_face_type_id;
		clocks_timer_face_type_id = g_type_register_static (gtk_stack_get_type (), "ClocksTimerFace", &g_define_type_info, 0);
		g_type_add_interface_static (clocks_timer_face_type_id, CLOCKS_TYPE_CLOCK, &clocks_clock_info);
		ClocksTimerFace_private_offset = g_type_add_instance_private (clocks_timer_face_type_id, sizeof (ClocksTimerFacePrivate));
		g_once_init_leave (&clocks_timer_face_type_id__volatile, clocks_timer_face_type_id);
	}
	return clocks_timer_face_type_id__volatile;
}

static void
_vala_clocks_timer_face_get_property (GObject * object,
                                      guint property_id,
                                      GValue * value,
                                      GParamSpec * pspec)
{
	ClocksTimerFace * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, CLOCKS_TIMER_TYPE_FACE, ClocksTimerFace);
#line 67 "../src/timer.vala"
	switch (property_id) {
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_LABEL_PROPERTY:
#line 67 "../src/timer.vala"
		g_value_set_string (value, clocks_clock_get_label ((ClocksClock*) self));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_ICON_NAME_PROPERTY:
#line 67 "../src/timer.vala"
		g_value_set_string (value, clocks_clock_get_icon_name ((ClocksClock*) self));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_HEADER_BAR_PROPERTY:
#line 67 "../src/timer.vala"
		g_value_set_object (value, clocks_clock_get_header_bar ((ClocksClock*) self));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_PANEL_ID_PROPERTY:
#line 67 "../src/timer.vala"
		g_value_set_enum (value, clocks_clock_get_panel_id ((ClocksClock*) self));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_STATE_PROPERTY:
#line 67 "../src/timer.vala"
		g_value_set_enum (value, clocks_timer_face_get_state (self));
#line 67 "../src/timer.vala"
		break;
#line 1932 "timer.c"
		default:
#line 67 "../src/timer.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 67 "../src/timer.vala"
		break;
#line 1938 "timer.c"
	}
}

static void
_vala_clocks_timer_face_set_property (GObject * object,
                                      guint property_id,
                                      const GValue * value,
                                      GParamSpec * pspec)
{
	ClocksTimerFace * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, CLOCKS_TIMER_TYPE_FACE, ClocksTimerFace);
#line 67 "../src/timer.vala"
	switch (property_id) {
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_LABEL_PROPERTY:
#line 67 "../src/timer.vala"
		clocks_clock_set_label ((ClocksClock*) self, g_value_get_string (value));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_ICON_NAME_PROPERTY:
#line 67 "../src/timer.vala"
		clocks_clock_set_icon_name ((ClocksClock*) self, g_value_get_string (value));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_HEADER_BAR_PROPERTY:
#line 67 "../src/timer.vala"
		clocks_clock_set_header_bar ((ClocksClock*) self, g_value_get_object (value));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_PANEL_ID_PROPERTY:
#line 67 "../src/timer.vala"
		clocks_clock_set_panel_id ((ClocksClock*) self, g_value_get_enum (value));
#line 67 "../src/timer.vala"
		break;
#line 67 "../src/timer.vala"
		case CLOCKS_TIMER_FACE_STATE_PROPERTY:
#line 67 "../src/timer.vala"
		clocks_timer_face_set_state (self, g_value_get_enum (value));
#line 67 "../src/timer.vala"
		break;
#line 1982 "timer.c"
		default:
#line 67 "../src/timer.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 67 "../src/timer.vala"
		break;
#line 1988 "timer.c"
	}
}

